# This is the "one-and-only" configuration for OpenDaVINCI.
# Its format is like:
#
# section.key=value
#
# If you have several modules of the same type, the following configuration
# scheme applies:
#
# global.key=value # <-- This configuration applies for all modules.
#
# section.key=value # <-- This configuration applies for all modules of type "section".
#
# section:ID.key=value # <-- This configuration applies for the module "ID" of type "section".


###############################################################################
###############################################################################
#
# GLOBAL CONFIGURATION
#

# The following attributes define the buffer sizes for recording and
# replaying. You need to adjust these parameters depending on the
# camera resolution for example (640x480x3 --> 1000000 for memorySegment,
# 1280x720x3 --> 2800000).
global.buffer.memorySegmentSize = 2800000 # Size of a memory segment in bytes.
global.buffer.numberOfMemorySegments = 4  # Number of memory segments.


###############################################################################
###############################################################################
#
# NEXT, THE CONFIGURATION FOR OpenDaVINCI TOOLS FOLLOWS. 
#
###############################################################################
###############################################################################
#
# CONFIGURATION FOR ODSUPERCOMPONENT
#

# If the managed level is pulse_shift, all connected modules will be informed
# about the supercomponent's real time by this increment per module. Thus, the
# execution times per modules are better aligned with supercomponent and the
# data exchange is somewhat more predictable.
odsupercomponent.pulseshift.shift = 10000 # (in microseconds)

# If the managed level is pulse_time_ack, this is the timeout for waiting for
# an ACK message from a connected client.
odsupercomponent.pulsetimeack.timeout = 5000 # (in milliseconds)

# If the managed level is pulse_time_ack, the modules are triggered sequentially
# by sending pulses and waiting for acknowledgment messages. To allow the modules
# to deliver their respective containers, this yielding time is used to sleep
# before supercomponent sends the pulse messages the next module in this execution
# cycle. This value needs to be adjusted for networked simulations to ensure
# deterministic execution. 
odsupercomponent.pulsetimeack.yield = 5000 # (in microseconds)

# List of modules (without blanks) that will not get a pulse message from odsupercomponent.
odsupercomponent.pulsetimeack.exclude = odcockpit

###############################################################################
###############################################################################
#
# CONFIGURATION FOR ODRECORDER
#
odrecorder.output = file://recorder.rec
odrecorder.remoteControl = 0 # 0 = no remote control, 1 = allowing remote control (i.e. start and stop recording)
odrecorder.dumpSharedData = 1 # 0 = do not dump shared images and shared images, 1 = otherwise

###############################################################################
###############################################################################
#
# CONFIGURATION FOR ODRECORDERH264
#
#odrecorderh264.output = file://recorder.rec # If this parameter is not present, odrecorderh264 will autogenerate a filename.
odrecorderh264.remoteControl = 0 # 0 = no remote control, 1 = allowing remote control (i.e. start and stop recording)
odrecorderh264.dumpSharedData = 0 # 0 = do not dump shared images and shared images, 1 = otherwise
odrecorderh264.lossless = 1 # Set to 1 to enable h264 lossless encoding.
odrecorderh264.portbaseforchildprocesses = 29000 # Every spawned child processes is connecting to the parent process via TCP using the base port plus its increasing ID.

###############################################################################
###############################################################################
#
# NEXT, THE CONFIGURATION FOR OPENDLV SOFTWARE FOLLOWS. 
#


# action-setopticalrotation
logic-action-setopticalrotation.correctionGain = 0.2
logic-action-setopticalrotation.maxStimulusAge =  1.0
logic-action-setopticalrotation.patienceDuration = 0.2
logic-action-setopticalrotation.stimulusJerkThreshold =  0.02
logic-action-setopticalrotation.stimulusRateThreshold = 0.02
logic-action-setopticalrotation.stimulusThreshold = 0.02

# knowledge-scene
logic-knowledge-scene.mergeDistance = 4.0
logic-knowledge-scene.validUntilDuration = 1
logic-knowledge-scene.memoryCapacity = 5.0 # seconds
logic-knowledge-scene.debug = 0

# perception-detectlane
logic-perception-detectlane.intensityThreshold = 130
logic-perception-detectlane.adapThreshKernelSize = 5
logic-perception-detectlane.adapThreshConst = 25
logic-perception-detectlane.cannyThreshold = 160 #220
logic-perception-detectlane.houghThreshold = 70 #80,100
logic-perception-detectlane.lineDiff = 1.6 #1.6
logic-perception-detectlane.HorisontalLimit = 3 # meters on each side we should consider
logic-perception-detectlane.OneLineDiff = 5.0 #how much a line can differ between the two points
logic-perception-detectlane.memThreshold = 0.5 #seconds
logic-perception-detectlane.upperLaneLimit = 250
logic-perception-detectlane.lowerLaneLimit = 450
logic-perception-detectlane.screenWidth = 1280
logic-perception-detectlane.screenHeight = 720
logic-perception-detectlane.debug = 1
logic-perception-detectlane.camera = front-left
logic-perception-detectlane.blurKernelSize = 3
logic-perception-detectlane.roiX = 30 #205 Pixels away from the upper left corner in X
logic-perception-detectlane.roiWidth = 1100 #110 Done Pixel width of the captured box in X
logic-perception-detectlane.roiY = 200 #200 Pixels away from the upper part of picture in Y
logic-perception-detectlane.roiHeight = 400 #300 Pixel height of the captured box in Y

# proxy-trimble
proxy-trimble.ip = 10.40.40.13
proxy-trimble.port = 9999
proxy-trimble.debug = 0

# proxy-camera-axis
proxy-camera-axis.type = opencv-ip-axis
proxy-camera-axis.name = front-left
proxy-camera-axis.address = 10.40.40.90
proxy-camera-axis.username = root
proxy-camera-axis.password = gcdc
proxy-camera-axis.width = 1280
proxy-camera-axis.height = 720
proxy-camera-axis.bpp = 3
proxy-camera-axis.mount.x = 3.1
proxy-camera-axis.mount.y = 0.5
proxy-camera-axis.mount.z = 1.0
proxy-camera-axis.mount.roll = 0.0
proxy-camera-axis.mount.pitch = -0.1
proxy-camera-axis.mount.yaw = 0.2
proxy-camera-axis.debug = 0

# proxy-fh16
proxy-rhino-can.devicenode = can2  # PEAK CAN device using SocketCAN.
proxy-rhino-can.record_gcm = 0           # 1 = dump generic CAN messages.
proxy-rhino-can.record_mapped_data = 0   # 1 = record mapped containers.
proxy-rhino-can.enableActuationBrake = 1
proxy-rhino-can.enableActuationSteering = 1
proxy-rhino-can.enableActuationThrottle = 1
